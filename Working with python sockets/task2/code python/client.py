import socket, time, threading  # threading бібліотека для многопоточності

"""
    Тобто тут ми відправляєм від одного користувача повідомлення на сервер
    тоді сервер обробляє їх і відправляє результат клієнту
"""


def receving(name, sock): # приймаєм повідомлення від сервера
    while not shutdownd:  # поки клієнт присутній на сервері
        try:
            data, addr = sock.recvfrom(1024)  # записуєм повідомлення і адресу клієнта в змінні
            print(data.decode("utf-8"))  # виводим розшифроване повідомлення на екран клієнту
        except:
            pass


shutdownd = False  # для того щоб знати коли клієнт присутній на сервері
join      = False  # для того щоб знати чи даний клієнт є новим клієнтом а не присутнім на даному сервері

host = '127.0.0.1'
port = 0                # будь-який бо сервер сам створює по суті йому порт

server = ('127.0.0.1', 1035)

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # створення сокета --- підтримка технології TCP, IP
s.bind((host, port))  # зв'язує сокет з локальним адресним протоколом
s.setblocking(0)      # допоміжна функція щоб не виникало лишніх помилок оскільки сервер  у нас це многопоточність

print("Команда закінчується крапкою з комою")

rT = threading.Thread(target=receving, args=("RecvThread", s))  # робимо многопоточність, тобто відображення повідомлень у кожного клієнта в той же час
rT.start()  # початок многопоточністі

while (shutdownd == False):   # поки клієнт не вийшов
    if (join == False):     # перевірка чи клієнт є новим для сервера
        s.sendto((" --> клієнт приєднався").encode("utf-8"), server)  # відправляєм на серевр повідомлення
        join = True
    else:
        try:
            message = input()
            if message != "":
                s.sendto((" :: " + message).encode("utf-8"), server)  # відправляєм на серевр повідомлення
            time.sleep(0.2)  # робимо паузу в 0.2 секунди, щоб не було багів
        except:
            s.sendto((" --> клієнт віддєднався").encode("utf-8"), server)  # відправляєм на серевр повідомлення
            shutdownd = True

rT.join()  # для многопоточності
s.close()  # закриття сокету
